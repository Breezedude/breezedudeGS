#include "aprs.h"

Aprs::Aprs(){
    _user = "";
    client = NULL;
}

void Aprs::setClient(Client *_client){
    client = _client;
}

bool Aprs::begin(String user,String version){
    _version = version;
    _user = user;
    aprs_connected = false;
    GPSOK = 0;
    tStatus = 0;
    if (client == NULL){ //if now client is set, we use the wifi-client
      client = new WiFiClient();
    }
    return true;
}

void Aprs::end(void){
    if(client){
        client->stop();
    }
}

int32_t getStringValue(String s,String begin,String end,int32_t fromIndex,String *sRet){
    int pos = s.indexOf(begin,fromIndex);
    if (pos < 0) return -1;
    pos += begin.length();
    int pos2 = s.indexOf(end,pos);
    if (pos2 < 0) return -1;
    *sRet = s.substring(pos,pos2);
    return pos2;
}

float kmh2mph(float f){
  return f / 1.609;
}

float deg2f(float f){
  return (f * 9/5) + 32;
}

void Aprs::setAirMode(bool _AirMode){
    AirMode = _AirMode;
}

void Aprs::sendLoginMsg(void){
    String login ="user " + _user + " pass " + calcPass(_user) + " vers " + _version + "\r\n";
    //log_i("%s",login.c_str());
    client->print(login);
    client->flush();
}

String Aprs::calcPass(String user){
    const int length = user.length();
    uint8_t buffer[length];
    String myString = user.substring(0,10);
    myString.toUpperCase();
    memcpy(buffer, myString.c_str(), length);
    uint16_t hash = 0x73e2;
    int i = 0;
    while (i < length){
        hash ^= buffer[i] << 8;
        if ((i+1) < length){
            hash ^= buffer[i+1];
        }
        i += 2;
    }
    hash &= 0x7fff;
    return String(hash);
}

void Aprs::setAprsServer(String server, uint32_t port){
    strcpy(aprs_server, server.c_str());
    aprs_port = port;
}


void Aprs::connect2Server(uint32_t tAct){
    static uint32_t tConnRetry = tAct;
    initOk = INIT_NONE;
    aprs_connected = false;
    if (aprs_port && ((tAct - tConnRetry) >= 5000) && (aprs_server[0] != '\0')){
        tConnRetry = tAct;
        client->stop();
        client->flush();
        int ret = client->connect(aprs_server, aprs_port);
        if (ret) {
            sendLoginMsg();
            aprs_connected = true;
            Serial.println(F("Connected to aprs server"));
        } else {
            Serial.println(F("aprs connect failed"));
        }
        
    }
    
}

void Aprs::checkLine(String line){
    String s = "";
    int32_t pos = 0;
    //log_i("%s",line.c_str());
    if (!line.startsWith("# aprsc")){
      //log_i("%s:%s",getActTimeString().c_str(),line.c_str());
    }
    if (initOk == INIT_NONE){
        pos = getStringValue(line,"server ","\r\n",0,&s);
        if (pos > 0){
            tStatus = 0;
            tRecBaecon = millis() - APRSSTATUSINTERVALL;
            _servername = s;
            initOk = INIT_CONNECTED;
            log_i("logged in successfully");
        }
    }
}

void Aprs::setGPS(float lat,float lon,float alt,float speed,float heading){
    _lat = lat;
    _lon = lon;
    _alt = alt;
    _speed = speed;
    _heading = heading;
    GPSOK = 1;
}

/* uint8_t Aprs::getSenderDetails(bool onlinetracking,aircraft_t aircraftType,uint8_t addressType){
    uint8_t type = 0;
    type = (uint8_t)aircraftType;
    
    switch (aircraftType)
    {
    case paraglider:
        type = 7;
        break;
    case hangglider:
        type = 6;
        break;
    case balloon:
        type = 11;
        break;
    case glider:
        type = 1;
        break;
    case poweredAircraft:
        type = 8;
        break;
    case helicopter:
        type = 3;
        break;
    case uav:
        type = 13;
        break;
    default:
        type = 15;
        break;
    }
    
    type = type << 2;
    if (!onlinetracking){
        type += 0x80; //first stealth mode boolean (should never be "1")
    }
    //cause, GXAircom is also able to send legacy-mode --> we send always as flarm-device.
    //address-type
    //  RANDOM(0) - changing (random) address generated by the device
    //	ICAO(1)
    //	FLARM(2)  FLARM HW
    //	OGN(3)    OGN tracker HW    
    type += (addressType & 0x03);
    return type;
}
*/

uint8_t Aprs::getSenderDetails(bool OnlineTracking, aircraft_t aircraftType) {
    /*
      OGN 'idXX' encoding proposal:
      - Bits 0..3: Aircraft type (0-15)
      - Bit 4: OnlineTracking (1 = online tracking enabled)
      - Bits 5..7: Technology
          000 = OGN
          001 = FLARM
          010 = PilotAware
          011 = FANET (FNT)
          100 = ADS-B
          101 = Mode-S
          110 = SPOT
          111 = Other

      We will use:
      Bits 5..7 = 011 for FANET -> 0x60
      Bit 4 = OnlineTracking << 4
      Bits 0..3 = aircraftType & 0x0F
    */

    const uint8_t FANET_TECH_BITS = 0x60; // 0110 0000 -> FANET
    uint8_t value = FANET_TECH_BITS | ((OnlineTracking ? 1 : 0) << 4) | (aircraftType & 0x0F);
    return value;
}

//String Aprs::getOrigin(uint8_t addressType){
//  uint8_t adr = addressType & 0x03;
//  if (addressType & 0x80){
//    //it was a Fanet-MSG
//    if (adr == 2){
//        return "FLR";
//    }else if (adr == 3){
//        return "OGN";
//    }else{
//        return "FNT";
//    }
//  }else{
//    if (adr == 1){
//      return "ICA";
//    }else if (adr == 2){
//      return "FLR";
//    }else if (adr == 3){
//      return "OGN";
//    }else{
//      return "RND";
//    }
//  }
//}

void Aprs::sendNameData(String devId,String name,float snr){
    if (initOk < INIT_FULL) return; //nothing todo
    String sTime = getActTimeString();
    if (sTime.length() <= 0) return;
    char buff[200];
    sprintf (buff,"%s%s>%s,qAS,%s:>%sh Name=\"%s\" %0.1fdB\r\n","FNT",devId.c_str(),_user.c_str(),aprsTag,sTime.c_str(),name.c_str(),snr);
    
    client->print(buff); 
    client->flush();   
    //log_i("%s",buff);

}

bool Aprs::sendWeatherData(weatherData *wData){

    if (initOk < INIT_FULL) return false; //nothing todo
    float lLat = abs(wData->lat);
    float lLon = abs(wData->lon);
    int latDeg = int(lLat);
    int latMin = (roundf((lLat - int(lLat)) * 60 * 1000));
    int lonDeg = int(lLon);
    int lonMin = (roundf((lLon - int(lLon)) * 60 * 1000));
    int mHum = (int)wData->Humidity;
    if (mHum >= 100){ //humidity 100% --> 00
        mHum = 0;
    }else if (mHum == 0){
        mHum = 1;
    }
    String sTime = getTimeStringFromTimestamp(wData->timestamp);
    if (sTime.length() <= 0) return false;
    char buff[200];
    String send = "";
    sprintf (buff,"FNT%s>%s,qAS,%s:/%sh%02d%02d.%02d%c/%03d%02d.%02d%c_%03d/%03dg%03d"
    ,wData->devId.c_str(),aprsTag,_user.c_str(),sTime.c_str(),latDeg,latMin/1000,latMin/10 %100,(wData->lat < 0)?'S':'N',lonDeg,lonMin/1000,lonMin/10 %100,(wData->lon < 0)?'W':'E',
    int(wData->wHeading),int(kmh2mph(wData->wSpeed)),int(kmh2mph(wData->wGust)));
    send += buff;
    if (wData->bTemp){
        sprintf (buff,"t%03d",int(deg2f(wData->temp)));
        send += buff;
    }
    if (wData->bRain){
        if (wData->rain1h >= 100){
            send += "r999";
        }else{
            sprintf (buff,"r%03d",int(wData->rain1h * 10));
            send += buff;
        }
        if (wData->rain24h >= 100){
            send += "p999";
        }else{
            sprintf (buff,"p%03d",int(wData->rain24h * 10));
            send += buff;
        }
    }
    if (wData->bHumidity){
        sprintf (buff,"h%02d",mHum);
        send += buff;
    }
    if (wData->bBaro){
        sprintf (buff,"b%05d",int(wData->Baro * 10));
        send += buff;
    }
    sprintf (buff," %0.1fdB\r\n",wData->snr);
    send += buff;

    
   
    size_t res = client->print(send.c_str()); 
    client->flush();
               
    
    log_i("%s",send.c_str());
    return res > 0;
}

void Aprs::sendGroundTrackingData(time_t timestamp,float lat,float lon,float alt,String devId,uint8_t state,uint8_t adressType,float snr){
  //FLR110F62>OGNFNT,qAS,FNB110F62:/202017h4833.73N/01307.57Eg299/001/A=001065 !W60! id3E110F62 -02fpm FNT71
  
  if (initOk < INIT_FULL) return; //nothing todo
  char buff[255];
  char altBuff[20];
  float lLat = abs(lat);
  float lLon = abs(lon);
  int latDeg = int(lLat);
  int latMin = (roundf((lLat - int(lLat)) * 60 * 1000));
  int lonDeg = int(lLon);
  int lonMin = (roundf((lLon - int(lLon)) * 60 * 1000));
  String sTime = getActTimeString(timestamp);
  if (sTime.length() <= 0) return;
  if (alt > 0.0){
    sprintf(altBuff,"/A=%06d",int(alt * 3.28084));
  }else{
    altBuff[0] = 0;
  }
  sprintf (buff,"%s%s>%s,qAS,%s:/%sh%02d%02d.%02d%c\\%03d%02d.%02d%cn%s !W%01d%01d! id%02X%s FNT%X %0.1fdB\r\n" //3F OGN-Tracker and device 15
  ,getOrigin(adressType).c_str(),devId.c_str(),aprsTag,_user.c_str(),sTime.c_str(),latDeg,latMin/1000,latMin/10 %100,(lat < 0)?'S':'N',lonDeg,lonMin/1000,lonMin/10 %100,(lon < 0)?'W':'E',altBuff,int(latMin %10),int(latMin %10),getSenderDetails(true,aircraft_t::STATIC_OBJECT),devId.c_str(),state,snr);
  
 
  client->print(buff);
  client->flush();
                
  //log_i("%s",buff);

}

uint8_t Aprs::getFANETAircraftType(aircraft_t aircraftType){
  switch (aircraftType)
  {
  case PARA_GLIDER:
    return 1;
  case HANG_GLIDER:
    return 2;
  case BALLOON:
    return 3;
  case GLIDER_MOTOR_GLIDER:
    return 4;
  case TOW_PLANE:
    return 5;
  case HELICOPTER_ROTORCRAFT:
    return 6;
  case UAV:
    return 7;
  default:
    return 0; //unknown
  }
  return 0; //unknown
}

void Aprs::sendTrackingData(trackingData *td){
    if (initOk < INIT_FULL) return;
    if ((td->aircraftType < 0) || (td->aircraftType > 15)){
        Serial.printf("wrong aircraftType %d --> set to unknown\n",(int)(td->aircraftType));
        td->aircraftType = acft_Other;
    }
    char buff[255];
    float lLat = abs(td->lat);
    float lLon = abs(td->lon);
    int latDeg = int(lLat);
    int latMin = (roundf((lLat - int(lLat)) * 60 * 1000));
    int lonDeg = int(lLon);
    int lonMin = (roundf((lLon - int(lLon)) * 60 * 1000));
    String sTime = getActTimeString(td->timestamp);
    if (sTime.length() <= 0) return;
    int pos = 0;
    pos += snprintf(&buff[pos],255-pos,"%s",td->adressType.c_str());
    pos += snprintf(&buff[pos],255-pos,"%s>%s,qAS,",td->devId.c_str(), aprsTag);
    pos += snprintf(&buff[pos],255-pos,"%s:/",_user.c_str());
    pos += snprintf(&buff[pos],255-pos,"%sh",sTime.c_str());
    pos += snprintf(&buff[pos],255-pos,"%02d%02d.%02d",latDeg,latMin/1000,latMin/10 %100);
    pos += snprintf(&buff[pos],255-pos,"%c",(td->lat < 0)?'S':'N');
    pos += snprintf(&buff[pos],255-pos,"%c",AprsIcon[td->aircraftType][0]);
    pos += snprintf(&buff[pos],255-pos,"%03d%02d.%02d",lonDeg,lonMin/1000,lonMin/10 %100);
    pos += snprintf(&buff[pos],255-pos,"%c",(td->lon < 0)?'W':'E');
    pos += snprintf(&buff[pos],255-pos,"%c",AprsIcon[td->aircraftType][1]);
    pos += snprintf(&buff[pos],255-pos,"%03d/%03d",int(td->heading),int(td->speed * 0.53996));
    pos += snprintf(&buff[pos],255-pos,"/A=%06d",int(td->alt * 3.28084));
    pos += snprintf(&buff[pos],255-pos," !W%01d%01d! ",int(latMin %10),int(latMin %10));
    pos += snprintf(&buff[pos],255-pos,"id%02X%s ",getSenderDetails(td->onlineTracking,(aircraft_t)(td->aircraftType)),td->devId.c_str());
    pos += snprintf(&buff[pos],255-pos,"%+04.ffpm ",td->climb*196.85f);
    pos += snprintf(&buff[pos],255-pos,"FNT1%d ",getFANETAircraftType((aircraft_t)(td->aircraftType)));
    pos += snprintf(&buff[pos],255-pos,"%0.1fdB\r\n",td->snr);
    client->print(buff);
    client->flush();
                    
    
}

void Aprs::setStatusData(float pressure, float temp,float hum, float battVoltage,uint8_t battPercent){
    _Pressure = pressure;
    _Temp = temp;
    _Hum = hum;
    _BattVoltage = battVoltage;
    _BattPercent = battPercent;
}

void Aprs::sendReceiverStatus(String sTime){
    String sStatus = _user + ">" + aprsTag + ",TCPIP*,qAC," + _servername + ":>" + sTime + "h " + _version + " CPU:" + String(_BattPercent/100.0,1) + " ";
    if (!isnan(_alt)){
        sStatus += String(_alt,0) + "m "; //send altitude
    }
    if (!isnan(_Pressure)){
        sStatus += String(_Pressure,1) + "hPa "; //send pressure
    }
    if (!isnan(_Temp)){
        if (_Temp >= 0){
            sStatus += "+";
        }
        sStatus += String(_Temp,1) + "C "; //send Temp
    }
    if (!isnan(_Hum)){
        sStatus += String(_Hum,0) + "% "; //send humidity
    }
    if (!isnan(_BattVoltage)){
        sStatus += String(_BattVoltage,2) + "V "; //send batt-voltage
    }
    sStatus += "\r\n";
    
   
    client->print(sStatus);
    client->flush();

    
    if (initOk < INIT_FULL) initOk = INIT_FULL; //now we can send, because we have sent GPS-Position
    log_i("%s",sStatus.c_str());
}

void Aprs::sendReceiverBeacon(String sTime){
    char buff[200];
    float lLat = abs(_lat);
    float lLon = abs(_lon);
    int latDeg = int(lLat);
    int latMin = (roundf((lLat - int(lLat)) * 60 * 1000));
    int lonDeg = int(lLon);
    int lonMin = (roundf((lLon - int(lLon)) * 60 * 1000));

    if (AirMode){
        sprintf (buff,"%s>%s,TCPIP*,qAC,%s:/%sh%02d%02d.%02d%cI%03d%02d.%02d%c&%03d/%03d/A=%06d !W%01d%01d!\r\n"
                    ,_user.c_str(),aprsTag,_servername.c_str(),sTime.c_str(),latDeg,latMin/1000,latMin/10 %100,(_lat < 0)?'S':'N',lonDeg,lonMin/1000,lonMin/10 %100,(_lon < 0)?'W':'E',int(_heading),int(_speed * 0.53996),int(_alt * 3.28084),int(latMin %10),int(latMin %10));
    }else{
        sprintf (buff,"%s>%s,TCPIP*,qAC,%s:/%sh%02d%02d.%02d%cI%03d%02d.%02d%c&/A=%06d\r\n"
                    ,_user.c_str(),aprsTag,_servername.c_str(),sTime.c_str(),latDeg,latMin/1000,latMin/10 %100,(_lat < 0)?'S':'N',lonDeg,lonMin/1000,lonMin/10 %100,(_lon < 0)?'W':'E',int(_alt * 3.28084));
    }

    client->print(buff);
    client->flush();
 
    
    if (initOk < INIT_REGISTERED) initOk = INIT_REGISTERED; //now we can send, because we have sent GPS-Position
    //log_i("%s",buff);
}

String Aprs::getActTimeString(time_t timestamp){
  struct tm timeinfo;
  char buff[20];
  gmtime_r(&timestamp, &timeinfo);
  sprintf (buff,"%02d%02d%02d",timeinfo.tm_hour,timeinfo.tm_min,timeinfo.tm_sec);
  //log_i("%s",buff);
  return String(buff);
}

String Aprs::getActTimeString(){
  char buff[20];
  if (timeStatus() == timeSet){
      //log_i("%d %d %d %d:%d:%d",year(),month(),day(),hour(),minute(),second());
      sprintf (buff,"%02d%02d%02d",hour(),minute(),second());
      //log_i("%s",buff);
      return String(buff);
  }else{
      return "";
  }
}

String Aprs::getTimeStringFromTimestamp(time_t timestamp) {
    struct tm *tm = localtime(&timestamp);
    char buff[7]; // 6 digits + null terminator
    sprintf(buff, "%02d%02d%02d", tm->tm_hour, tm->tm_min, tm->tm_sec);
    return String(buff);
}

void Aprs::sendStatus(uint32_t tAct){
    if (initOk > INIT_NONE){        
        if (GPSOK){
            if (((tAct - tRecBaecon) >= APRSSTATUSINTERVALL) || tRecBaecon == 0){
                tRecBaecon = tAct;
                tStatus = tAct;
                String sTime = getActTimeString();
                Serial.println(sTime);
                if (sTime.length() > 0){
                    sendReceiverBeacon(sTime);
                    //sendReceiverStatus(sTime);
                }
            }
        }
        //we have to send ReceiverBeacon and afterwards the status (Receiverbaecon always first)
        if (((tAct - tStatus) >= 5000) && (tStatus != 0)){
            String sTime = getActTimeString();
            if (sTime.length() > 0){
                sendReceiverStatus(sTime);
            }
            tStatus = 0;
        }
    }
}

void Aprs::readClient(){
  String line = "";
  if (client->available()){
    while (client->available()){
        char c = client->read(); //read 1 character 
        
        line += c; //read 1 character
        if (c == '\n'){
            checkLine(line);
            line = "";
        }
    }
  }
}

void Aprs::checkClientConnected(uint32_t tAct){
    static uint32_t tCheck = tAct;
    if ((tAct - tCheck) >= 5000){
        tCheck = tAct;
        if (!client->connected()){
            if(aprs_connected){
                Serial.println("aprs disonnected");
            }
            aprs_connected = false;
        }
    }
}

void Aprs::run(bool bNetworkOk){    
    uint32_t tAct = millis();    
    //if (WiFi.status() == WL_CONNECTED){
    if (bNetworkOk){
        checkClientConnected(tAct);
        if (aprs_connected){
            //Serial.print("aprs_connected: "); Serial.println(aprs_connected);
            readClient();
            sendStatus(tAct);
        }else{
            //not connected --> try to connect
            connect2Server(tAct);
        }
    }else{
        if(aprs_connected){
            Serial.println("WiFi disonnected");
        }
        aprs_connected = false;
    }
}